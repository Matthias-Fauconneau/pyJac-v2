#include "ocl_errorcheck.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <CL/cl.h>
#include <assert.h>

#define NUM_PLATFORMS (10)
#define MAX_DEVICE (10)

int main(int argc, char* argv[])
{
    cl_platform_id platform_id[NUM_PLATFORMS];
    cl_device_id device_ids[MAX_DEVICE];
    cl_context context = NULL;
    cl_command_queue command_queue = NULL;
    cl_program program = NULL;
    cl_uint ret_num_platforms;
    cl_uint ret_num_devices;
    cl_uint num_cores;

    cl_int return_code;

    //check args
    assert(argc >= 3 && "Missing arguements...");

    //arglist is:
    //#0 - the program name
    //#1 - the problem size
    //#2 - the number of cores [CPU only] or number of GPUs / accelerators [GPU only]

    cl_uint problem_size = atoi(argv[1]);
    cl_uint num_devices = atoi(argv[2]);

    char* kernel_path = "${kernel}";
    char* platform_check = "${platform}";
    char* build_options = "${build_options}";

    cl_device_type device_type = ${device_type};

    FILE *fp;
    unsigned char *source_bin;

    /* Load kernel source code */
    fp = fopen(kernel_path, "rb");
    if (!fp) {
        exit(-1);
    }
    //find file size
    fseek(fp, 0L, SEEK_END);
    size_t source_size = ftell(fp);
    rewind(fp);

    //read file
    source_bin = (char*)malloc(source_size);
    assert(fread(source_bin, 1, source_size, fp) == source_size && "Error reading source binary...");
    fclose(fp);

    /* Get platform/device information */
    check_err(clGetPlatformIDs(NUM_PLATFORMS, platform_id, &ret_num_platforms));
    cl_platform_id pid = NULL;
    for (int i = 0; i < ret_num_platforms; ++i)
    {
        //check if intel
        char pvendor[500];
        size_t psize = 500 * sizeof(char);
        check_err(clGetPlatformInfo(platform_id[i], CL_PLATFORM_VENDOR, psize, pvendor, NULL));
        if(strstr(pvendor, platform_check) != NULL)
        {
            pid = platform_id[i];
            break;
        }
    }

    if (device_type == CL_DEVICE_TYPE_CPU)
    {
        //num devices is actually the number of cores
        //Hence, we're going to create a subdevice limited to that # of cores
        num_cores = num_devices;
        //all systems tested show multi-cpus as a single device.  May need to update for MPI etc.
        num_devices = 1;
    }
    else if (num_devices >= MAX_DEVICE)
    {
        printf("Cannot create program with %s devices, please update MAX_DEVICE definition.\n");
        exit(EXIT_FAILURE);
    }

    //get the device to compile for
    check_err(clGetDeviceIDs(pid, device_type, num_devices, device_ids, &ret_num_devices));

    //now we need to create subdevices for the CPU
    if (device_type == CL_DEVICE_TYPE_CPU)
    {
        cl_uint num_compute;
        //first get the maximum number of sub partitions (i.e. logical threads)
        check_err(clGetDeviceInfo(device_ids[0], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(num_compute), &num_compute, NULL));
        assert(num_cores <= num_compute && "Too many cores used...");

        //ok, now we know we're ok
        //let's create a subdevice with the required number of compute units
        // Partition properties
        cl_device_partition_property properties[3];
        // Partition type
        properties[0] = CL_DEVICE_PARTITION_BY_COUNTS;
        // number of compute units
        properties[1] = 3;
        // List end
        properties[2] = CL_DEVICE_PARTITION_BY_COUNTS_LIST_END;

        // Specifies the size of the out_devices array
        cl_uint num_sub_devices = 1;
        // Provides a buffer for the generated subdevices with a number of elements specified by num_sub_devices
        cl_device_id sub_device_ids;
        // Create the subdevices for the device_id device
        check_err(clCreateSubDevices(device_ids, properties, num_sub_devices, &sub_device_ids, &ret_num_devices));
        //and assign to the device_ids
        device_ids = sub_device_ids;
    }

    //create context
    context = clCreateContext(NULL, ret_num_devices, &device_ids, NULL, NULL, &return_code);
    check_err(return_code);

    //create queue
    command_queue = clCreateCommandQueue(context, device_ids, 0, &return_code);
    check_err(return_code);

    /* Create Kernel program from the read in source binary */
    cl_int bin_status;
    program = clCreateProgramWithBinary(context, ret_num_devices, &device_ids, &source_size, &source_bin, &bin_status, &return_code)
    check_err(bin_status);
    check_err(return_code);

    /* Build Program */
    return_code = clBuildProgram(program, 1, &device_id, build_options, NULL, NULL);
    if (return_code != CL_SUCCESS)
    {
          printf("OpenCL failed to build the program...\n");

          size_t len;
          char *buffer;
          check_err(clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, sizeof(char*), NULL, &len));
          buffer = calloc(len, sizeof(char));
          check_err(clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, len * sizeof(char), buffer, NULL));
          printf("%s\n", buffer);
          free(buffer);

          clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(char*), NULL, &len);
          buffer = calloc(len, sizeof(char));
          clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, len * sizeof(char), buffer, NULL);
          printf("%s\n", buffer);
          free(buffer);

          check_err(return_code);
    }

    //now build the kernel

    /* declare buffers */
    ${mem_declares}

    /* Alloc buffers */
    ${mem_allocs}

    /* Memory Transfers, if any */
    ${mem_transfers}

    /* Create OpenCL Kernel */
    check_err(clCreateKernel(program, "${kernel_name}", &ret));

    /* Kernel arg setting */
    ${kernel_arg_set}

    size_t global_work_size[3] = {problem_size, 0, 0};
    size_t local_work_size[3] = {${vec_width}, 0, 0};

    /* run kernel */
    check_err(clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL, global_work_size, local_work_size, 0, NULL, NULL));

    /* Finalization */
    check_err(clFlush(command_queue));
    check_err(clFinish(command_queue));
    check_err(clReleaseKernel(kernel));
    check_err(clReleaseProgram(program));

    /* Memory Frees */
    ${mem_frees}

    check_err(clReleaseCommandQueue(command_queue));
    check_err(clReleaseContext(context));

    free(source_bin);
}
/*
OpenCL_kernel.c

A skeleton for pyJac opencl kernel execution

Based on https://www.olcf.ornl.gov/tutorials/opencl-vector-addition/
and https://www.fixstars.com/en/opencl/book/OpenCLProgrammingBook/calling-the-kernel/

Nicholas Curtis - 2017
*/

#include "mechanism.oclh"
#include "ocl_errorcheck.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <CL/cl.h>
#include <assert.h>
#include <stdbool.h>

#define NUM_PLATFORMS (16)
#define MAX_DEVICE (16)
#define MAX_CORES (100)

void read_initial_conditions(const char* filename, int NUM, double** T_host,
                                double** conc_host, double** var_host,
                                const char order);

//the source -> binary compiler is separate
void compiler();

/* declare host/cl buffers */
${mem_declares}

/*
Execute the built opencl kernel

Parameters
----------
problem_size : cl_uint
    The number of conditions to execute for
kernel : cl_kernel
    The built kernel
queue : cl_command_queue
    The command queue
${knl_args_doc}
*/
void execute_kernel(cl_uint problem_size,
    cl_kernel kernel, cl_command_queue queue, ${knl_args})
{
    /* Memory Transfers into the kernel, if any */
    ${mem_transfers_in}

    size_t global_work_size[3] = {problem_size, 0, 0};
    size_t local_work_size[3] = {${vec_width}, 0, 0};

    /* run kernel */
    check_err(clEnqueueNDRangeKernel(queue, kernel, 1, NULL, global_work_size, local_work_size, 0, NULL, NULL));

    // Wait for the command queue to get serviced before reading back results
    clFinish(queue);

    /* Memory Transfers out */
    ${mem_transfers_out}
}

/*
Initialize memory & assign kernel args for the kernel

Parameters
----------
problem_size : cl_uint
    The number of conditions to execute for
num_devices : uint
    The number of devices to use.  If for GPUs/accelerators, this is the # of GPUs to use
    If for CPUs, this is the number of logical cores to use
kernel : cl_kernel [out]
    The kernel output will be stored here
program : cl_program
    The built OpenCL program
context : cl_context
    The opencl context for execution
*/
void mem_init(cl_uint problem_size, cl_kernel kernel, cl_program program,
                    cl_context context)
{
    cl_int return_code;
    /* Alloc buffers */
    ${mem_allocs}

    /* Create OpenCL Kernel */
    kernel = clCreateKernel(program, "${kernel_name}", &return_code);
    check_err(return_code);

    /* Kernel arg setting */
    ${kernel_arg_set}
}

/*
Create opencl kernel

Parameters
----------
problem_size : cl_uint
    The number of conditions to execute for
num_devices : uint
    The number of devices to use.  If for GPUs/accelerators, this is the # of GPUs to use
    If for CPUs, this is the number of logical cores to use
kernel : cl_kernel [out]
    The kernel output will be stored here
program : cl_program [out]
    The built OpenCL program will be stored here
context : cl_context [out]
    The opencl context for execution
queue : cl_command_queue [out]
    The opencl execution queue
*/
void init(cl_uint problem_size, cl_uint num_devices, cl_kernel kernel,
            cl_program program, cl_context context, cl_command_queue queue)
{
    cl_platform_id platform_id[NUM_PLATFORMS];
    cl_device_id device_ids[MAX_DEVICE];
    cl_uint ret_num_platforms;
    cl_uint ret_num_devices;
    cl_uint num_cores;
    cl_int return_code;

    char* kernel_paths[${num_source}] = {${kernels}};
    char* platform_check = "${platform}";
    char* build_options = "${build_options}";
    size_t source_sizes[${num_source}];

    cl_device_type device_type = ${device_type};

    FILE *fp;
    unsigned char* source_bins[${num_source}];

    for (int i = 0; i < ${num_source}; ++i)
    {
        /* Load kernel source code */
        fp = fopen(kernel_paths[i], "rb");
        if (!fp) {
            exit(-1);
        }
        //find file size
        fseek(fp, 0L, SEEK_END);
        source_sizes[i] = ftell(fp);
        rewind(fp);

        //read file
        source_bins[i] = (unsigned char*)malloc(source_sizes[i]);
        assert(fread(source_bins[i], 1, source_sizes[i], fp) == source_sizes[i] && "Error reading source binary...");
        fclose(fp);
    }

    /* Get platform/device information */
    check_err(clGetPlatformIDs(NUM_PLATFORMS, platform_id, &ret_num_platforms));
    cl_platform_id pid = NULL;
    for (int i = 0; i < ret_num_platforms; ++i)
    {
        //check if intel
        char pvendor[100];
        size_t psize = 100 * sizeof(char);
        check_err(clGetPlatformInfo(platform_id[i], CL_PLATFORM_VENDOR, psize, pvendor, NULL));
        if(strstr(pvendor, platform_check) != NULL)
        {
            pid = platform_id[i];
            break;
        }
    }

    if (device_type == CL_DEVICE_TYPE_CPU)
    {
        //num devices is actually the number of cores
        //Hence, we're going to create a subdevice limited to that # of cores
        num_cores = num_devices;
        //all systems tested show multi-cpus as a single device.  May need to update for MPI etc.
        num_devices = 1;
    }
    else if (num_devices >= MAX_DEVICE)
    {
        printf("Cannot create program with %s devices, please update MAX_DEVICE definition.\n");
        exit(EXIT_FAILURE);
    }

    //get the device to compile for
    check_err(clGetDeviceIDs(pid, device_type, num_devices, device_ids, &ret_num_devices));

    //now we need to create subdevices for the CPU
    if (device_type == CL_DEVICE_TYPE_CPU)
    {
        cl_uint num_compute;
        //first get the maximum number of sub partitions (i.e. logical threads)
        check_err(clGetDeviceInfo(device_ids[0], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(num_compute), &num_compute, NULL));
        assert(num_cores <= num_compute &&
                num_cores <= MAX_CORES && "Too many cores used...");

        //ok, now we know we're ok
        //let's create a subdevice with the required number of compute units
        // Partition properties
        cl_device_partition_property properties[3];
        // Partition type
        properties[0] = CL_DEVICE_PARTITION_BY_COUNTS;
        // number of compute units
        properties[1] = 3;
        // List end
        properties[2] = CL_DEVICE_PARTITION_BY_COUNTS_LIST_END;

        // Specifies the size of the out_devices array
        cl_uint num_sub_devices = 1;
        // Provides a buffer for the generated subdevices with a number of elements specified by num_sub_devices
        cl_device_id sub_device_ids;
        // Create the subdevices for the device_id device
        check_err(clCreateSubDevices(device_ids[0], properties, num_sub_devices, &sub_device_ids, &ret_num_devices));
        //and assign to the device_ids
        device_ids[0] = sub_device_ids;
    }

    //for the moment, limit to one device
    assert(ret_num_devices == 1 && "Currently limited to a single device");

    //create context
    context = clCreateContext(NULL, ret_num_devices, &device_ids[0], NULL, NULL, &return_code);
    check_err(return_code);

    //create queue
    queue = clCreateCommandQueue(context, device_ids[0], 0, &return_code);
    check_err(return_code);

    /* Create Kernel program from the read in source binary */
    cl_int bin_status;
    program = clCreateProgramWithBinary(context, ret_num_devices, &device_ids[0], source_sizes, (const unsigned char**)source_bins, &bin_status, &return_code);
    check_err(bin_status);
    check_err(return_code);

    /* Build Program */
    return_code = clBuildProgram(program, ret_num_devices, &device_ids[0], build_options, NULL, NULL);
    if (return_code != CL_SUCCESS)
    {
          printf("OpenCL failed to build the program...\n");

          size_t len;
          char *buffer;
          check_err(clGetProgramBuildInfo(program, device_ids[0], CL_PROGRAM_BUILD_LOG, sizeof(char*), NULL, &len));
          buffer = calloc(len, sizeof(char));
          check_err(clGetProgramBuildInfo(program, device_ids[0], CL_PROGRAM_BUILD_LOG, len * sizeof(char), buffer, NULL));
          printf("%s\n", buffer);
          free(buffer);

          clGetProgramBuildInfo(program, device_ids[0], CL_PROGRAM_BUILD_STATUS, sizeof(char*), NULL, &len);
          buffer = calloc(len, sizeof(char));
          clGetProgramBuildInfo(program, device_ids[0], CL_PROGRAM_BUILD_STATUS, len * sizeof(char), buffer, NULL);
          printf("%s\n", buffer);
          free(buffer);

          check_err(return_code);
    }

    for(int i = 0; i <= ${num_source}; ++i)
        free(source_bins[i]);

    mem_init(problem_size, kernel, program, context);
}

/*
Resets the program for a change in problem size
*/
void newsize_finalize(cl_command_queue queue, cl_kernel kernel)
{
    /* Finalization */
    check_err(clFlush(queue));
    check_err(clReleaseKernel(kernel));
    check_err(clFinish(queue));

    /* Memory Frees */
    ${mem_frees}
}

/*
Completely cleanup the opencl kernel
*/
void finalize(cl_command_queue queue, cl_context context,
                cl_kernel kernel, cl_program program)
{
    //flush & free memory
    newsize_finalize(queue, kernel);

    //release programs and contexts
    check_err(clReleaseProgram(program));
    check_err(clReleaseCommandQueue(queue));
    check_err(clReleaseContext(context));
}

//knl specific vars
bool ${knl_name}_init = false;
cl_uint problem_size_store = 0;
cl_uint num_devices_store = 0;
cl_kernel kernel = NULL;
cl_program program = NULL;
cl_context context = NULL;
cl_command_queue queue = NULL;
void ${knl_name}(cl_uint problem_size, cl_uint num_devices,
                    double* h_T_arr, double* h_P_arr, double* h_conc)
{
    if (num_devices != num_devices_store && ${knl_name}_init)
    {
        //check to see if we need to completely reset (i.e. on device change)
        finalize(queue, context, kernel, program);
        ${knl_name}_init = false;
    }
    else if (problem_size != problem_size_store && ${knl_name}_init)
    {
        //check to see if the problem size changed, if so we need to realloc memory
        newsize_finalize(queue, kernel);
        mem_init(problem_size, kernel, program, context);
    }
    if(!${knl_name}_init)
    {
        init(problem_size, num_devices, kernel, program, context, queue);
        ${knl_name}_init = true;
    }
    execute_kernel(problem_size, kernel, queue, ${knl_args_pass});
}

int main(int argc, char* argv[])
{

    //check args
    assert(argc >= 3 && "Missing arguements...");

    //arglist is:
    //#0 - the program name
    //#1 - the problem size
    //#2 - the number of cores [CPU only] or number of GPUs / accelerators [GPU only]

    //first compile to binary
    compiler();

    cl_uint problem_size = atoi(argv[1]);
    cl_uint num_devices = atoi(argv[2]);

    h_T_arr = (double*)malloc(problem_size * sizeof(double));
    h_P_arr = (double*)malloc(problem_size * sizeof(double));
    h_conc = (double*)malloc(problem_size * NS * sizeof(double));

    //init memory & program
    init(problem_size, num_devices, kernel, program, context, queue);
    //read input data
    read_initial_conditions("${data_filename}", problem_size,
                                &h_T_arr, &h_conc, &h_P_arr,
                                '${order}');

    execute_kernel(problem_size, kernel, queue, ${knl_args_pass});

    finalize(queue, context, kernel, program);
}
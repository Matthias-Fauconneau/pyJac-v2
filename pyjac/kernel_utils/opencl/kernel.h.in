/*
OpenCL_kernel.h

A skeleton for pyJac opencl kernel header


Nicholas Curtis - 2017
*/

#ifndef KERNEL_H
#define KERNEL_H

#include "mechanism.oclh"
#include "vectorization.oclh"
#include "ocl_errorcheck.oclh"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
extern "C" {
    #include <CL/cl.h>
}
#include <stdbool.h>
#include "timer.oclh"

#define NUM_PLATFORMS (16)
#define MAX_DEVICE (16)

/*[[[cog
    import six
    from textwrap import indent
    from six.moves import cPickle as pickle
    from pyjac.utils import indent as stdindent
    # load serialized callgen
    with open(callgen, 'rb') as file:
        callgen = pickle.load(file)

    # and create memory tools
    from pyjac.kernel_utils.memory_tools import get_memory, HostNamer, DeviceNamer
    mem = get_memory(callgen, host_namer=HostNamer(), device_namer=DeviceNamer())

    from pyjac.kernel_utils.opencl.tools import get_kernel_args, get_temporaries
  ]]]
  [[[end]]]*/


// macro definitions
/*[[[cog
    from pyjac.utils import enum_to_string
    cog.outl('#define CL_LEVEL {}'.format(callgen.cl_level))
    cog.outl('#define {}'.format(enum_to_string(callgen.dev_mem_type).upper()))
  ]]]
  [[[end]]]*/


// base kernel class
class Kernel
{

public:
    Kernel();
    ~Kernel();
    void resize(size_t problem_size, size_t work_size);
    void finalize();
    virtual void compile() = 0;

    // info variables -- common to all kernels
    static const char* build_options;
    static const char* platform_check;
    static const unsigned int device_type;

protected:
    size_t per_run();
    size_t per_run(size_t problem_size);
    size_t this_run(size_t offset);

    // opencl context, kernel, etc.
    cl_kernel kernel;
    cl_program program;
    cl_context context;
    cl_command_queue queue;

    // flags indicating initialization status, etc.
    bool initialized;
    bool compiled;

    // past run sizes
    size_t problem_size;
    size_t max_per_run;
    size_t work_size;

    // info variables -- specified per kernel
    unsigned int num_source;
    char** kernel_paths;

    /*
    Create opencl kernel

    Parameters
    ----------
    size_t per_run: size_t
        The number of initial conditions to execute per-run, due to memory limits.
        May be >= problem_size
    problem_size : size_t
        The number of initial conditions to execute in total
    work_size : uint
        The number of OpenCL groups to launch.
        If using GPUs, this is the # of CUDA blocks to use
        If for CPUs, this is the number of logical cores to use
    */
    void init(size_t problem_size, cl_uint work_size);

    // memory initialization / release accomplished in sub-classes
    virtual void mem_init(size_t problem_size, size_t work_size) = 0;
    virtual void finalize_memory() = 0;
};

// and subclass(es)
/*[[[cog
for kernel, args in six.iteritems(callgen.kernel_args):
    cog.out("""
class {kernel_name}Kernel : public Kernel
{{
protected:
    // declare device buffers
""".format(kernel_name=kernel.title()), dedent=True, trimblanklines=True)

    # define kernel args
    for arg in callgen.kernel_data[kernel]:
        cog.outl(indent(mem.define(True, arg), stdindent))
    cog.out("""
    #ifdef PINNED
        // declare temporary pointers to hold mapped addresses
    """,  dedent=True, trimblanklines=True)
    # define temps
    for temp in get_temporaries(mem, callgen.kernel_data[kernel]):
        cog.outl(indent(temp, stdindent))
    cog.out("""
    #endif
    """,  dedent=True, trimblanklines=True)

    # overrides
    cog.outl(indent('void mem_init(size_t problem_size, size_t work_size);', stdindent))

    cog.outl('public:')
    cog.out('void compile();')

    # write constructor
    cog.out("""
    /*
    Base constructor -- no arguments necessary, for use with Cython.
    {name}Kernel::resize() must be called before use.
    */
    {name}Kernel();
    """.format(name=kernel.title()), dedent=False, trimblanklines=True)

    # write alternate constructor that allows memory initialization
    cog.out("""

    /*
    Initializing constructor.

    Parameters
    ---------
    problem_size : size_t
        The number of initial conditions to execute in total
    work_size : uint
        The number of OpenCL groups to launch.
        If using GPUs, this is the # of CUDA blocks to use
        If for CPUs, this is the number of logical cores to use
    */
    {name}Kernel(size_t problem_size, size_t work_size);
    """.format(name=kernel.title()), dedent=False, trimblanklines=True)

    cog.out("""

    /*
    Execute the OpenCL kernel '{}'

    Parameters
    ----------
    """.format(kernel), dedent=False, trimblanklines=True)

    for arg in callgen.kernel_args[kernel]:
        cog.outl("""
        {} : {}
            {}""".format(arg.name, *callgen.get_docs(arg)), dedent=False, trimblanklines=True)

    cog.out("""
    */
    void operator()({knl_args});
    """.format(knl_args=get_kernel_args(mem, callgen.kernel_args[kernel])), dedent=False, trimblanklines=True)

    # overrides
    cog.outl(indent('void finalize_memory();', stdindent))
]]]
[[[end]]]*/
};


#endif

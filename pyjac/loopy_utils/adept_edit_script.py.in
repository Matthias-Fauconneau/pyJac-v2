#! /usr/bin/env python

"""
A simple script that acts as the 'EDITOR' for loopy code generation,
changing simple code-generation patterns that cause errors for various
OpenCL implementations (mostly Intel)
"""

import sys
import re


def __get_file(filename, text_in=None):
    if filename.lower() == 'stdin':
        lines = text_in.split('\n')
    else:
        with open(filename, 'r') as file:
            lines = file.readlines()
    return lines


def __save_file(filename, lines):
    if filename.lower() != 'stdin':
        with open(filename, 'w') as file:
            file.writelines(lines)


def substitute(filename, text_in=None):
    # first replace what will become the inner kernel with the single indexed
    # version

    lines = """${single_kernel}""".splitlines(True)

    # search for body
    body_at = None
    for i, line in enumerate(lines):
        if line.strip() == '{':
            body_at = i
            break

    # first, replace all double's with adoubles
    # and substitute problem_size and j for zero, to correct indexing
    for i in range(body_at - 1, len(lines)):
        lines[i] = re.sub(r'double\b(?![^,]+${jac_name})', 'adouble', lines[i])
        if i >= body_at:
            lines[i] = lines[i].replace(str(${problem_size} - 1), '0')
            lines[i] = lines[i].replace('j', '0')

            # check for fmax
            lines[i] = re.sub(r'(fmax\(.+)\);', r'\1.value());', lines[i])

    # next we have to rename the inner function
    lines[body_at - 1] = re.sub(r'void\s*([\w_]+)', r'void ad_\1',
                                lines[body_at - 1])

    # add adouble stuff
    lines.insert(0, '#include "adept.h"\n#include<iostream>\n')
    lines.insert(1, 'using adept::adouble; // Import Stack and adouble from adept\n')

    # now insert new calling function

    lines.append("""

extern "C" {
${function_defn}{
    #pragma omp parallel for
    for (int ad_j = 0; ad_j < ${problem_size}; ++ad_j)
    {
        adept::Stack stack; // Where the derivative information is stored
        //initialize variables
        ${initializers}
        stack.new_recording(); // Start recording
        std::vector<adouble> ${ad_dep_name}(${dep_size}); // Create vector of active output variables
        ${kernel_call} // Run algorithm
        stack.independent(&${ad_indep_name}[0], ${indep_size}); // Identify independent variables
        stack.dependent(&${ad_dep_name}[0], ${dep_size}); // Identify dependent variables
        stack.jacobian(${jac_base_offset}); // Compute & store Jacobian in jac
        ${setters}
    }
}
}
        """)

    # replace restrict with __restrict__
    for i in range(len(lines)):
        lines[i] = re.sub(r'restrict\b', '__restrict__', lines[i])

    __save_file(filename, lines)
    return '\n'.join(lines)


if __name__ == '__main__':
    substitute(sys.argv[1], sys.argv[2:])

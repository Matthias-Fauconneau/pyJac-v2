#! /usr/bin/env python

"""
A simple script that acts as the 'EDITOR' for loopy code generation,
changing simple code-generation patterns that cause errors for various
OpenCL implementations (mostly Intel)
"""

import sys
import re


def __get_file(filename, text_in=None):
    if filename.lower() == 'stdin':
        lines = text_in.split('\n')
    else:
        with open(filename, 'r') as file:
            lines = file.readlines()
    return lines


def __save_file(filename, lines):
    if filename.lower() != 'stdin':
        with open(filename, 'w') as file:
            file.writelines(lines)


def substitute(filename, text_in=None):
    lines = __get_file(filename, text_in=text_in)

    # search for body
    body_at = None
    for i, line in enumerate(lines):
        if line.strip() == '{':
            body_at = i
            break

    # first, replace all double's with adoubles
    # restrict with __restrict__
    # and substitute problem_size and j for zero, to correct indexing
    for i in range(body_at - 1, len(lines)):
        lines[i] = re.sub(r'double\b', 'adouble', lines[i])
        lines[i] = re.sub(r'restrict\b', '__restrict__', lines[i])
        if i >= body_at:
            lines[i] = lines[i].replace(str(${problem_size} - 1), '0')
            lines[i] = lines[i].replace('j', '0')

    # add adouble stuff
    lines.insert(0, '#include "adept.h"\n')
    lines.insert(1, 'using adept::adouble; // Import Stack and adouble from adept\n')

    # now insert new calling function

    lines.insert(2,
                 """
${function_defn}{
    #pragma openmp parallel for
    for (int ad_j = 0; j < ${problem_size}; ++j)
    {
        adept::Stack stack; // Where the derivative information is stored
        //initialize variables
        ${initializers}
        stack.new_recording(); // Start recording
        std::vector<adouble> ${ad_dep_name}(${dep_size}); // Create vector of active output variables
        ${kernel_call} // Run algorithm
        stack.independent(&${ad_indep_name}[0], ${indep_size}); // Identify independent variables
        stack.dependent(&${ad_dep_name}[0], ${dep_size}); // Identify dependent variables
        stack.jacobian(${output}); // Compute & store Jacobian in jac
        for (int i = 0; i < ${dep_size}; ++i) // get dependent vars
        {
            ${dep} = ${ad_dep_name}[i].value();
        }
    }
}
        """)

    __save_file(filename, lines)
    return '\n'.join(lines)


if __name__ == '__main__':
    substitute(sys.argv[1], sys.argv[2:])

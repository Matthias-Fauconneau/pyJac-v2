/*
OpenCL_kernel.c

A skeleton for pyJac opencl kernel execution

Based on https://www.olcf.ornl.gov/tutorials/opencl-vector-addition/
and https://www.fixstars.com/en/opencl/book/OpenCLProgrammingBook/calling-the-kernel/

Nicholas Curtis - 2017
*/

#include "ocl_errorcheck.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <CL/cl.h>
#include <assert.h>
#include <bool.h>

#define NUM_PLATFORMS (16)
#define MAX_DEVICE (16)

void read_initial_conditions(const char* filename, int NUM, double** conc_host, double** var_host,
                                const char order);

//the source -> binary compiler is separate
void compiler();

/* declare host/cl buffers */
cl_mem d_Atroe;
cl_mem d_B;
cl_mem d_Btroe;
cl_mem d_Fcent;
cl_mem d_Fi;
cl_mem d_Kc;
cl_mem d_P_arr;
cl_mem d_Pr;
cl_mem d_T_arr;
cl_mem d_X;
cl_mem d_conc;
cl_mem d_cp;
cl_mem d_cv;
cl_mem d_h;
cl_mem d_kf;
cl_mem d_kf_fall;
cl_mem d_kr;
cl_mem d_pres_mod;
cl_mem d_problem_size;
cl_mem d_rop_fwd;
cl_mem d_rop_net;
cl_mem d_rop_rev;
cl_mem d_thd_conc;
cl_mem d_u;
cl_mem d_wdot;
double h_T_arr;
double h_P_arr;
double h_conc;
double h_Fi;
double h_wdot;

/*
Execute the built opencl kernel

Parameters
----------
problem_size : cl_uint
    The number of conditions to execute for
kernel : cl_kernel
    The built kernel
queue : cl_command_queue
    The command queue

T_arr : double*
    The array of temperatures


P_arr : double*
    The array of pressures


conc : double*
    The array of concentrations in C-order


Fi : double*
    The array of pressure-blending terms, in C-order.  Needed in order to set Fi terms to unity.


wdot : double*
    The array of species rates, in C-order

*/
void execute_kernel(cl_uint problem_size,
    cl_kernel kernel, cl_command_queue queue, double* h_T_arr, double* h_P_arr, double* h_conc, double* h_Fi, double* h_wdot)
{
    /* Memory Transfers into the kernel, if any */
    clEnqueueWriteBuffer(queue, d_T_arr, CL_TRUE, 0, problem_size * sizeof(double), h_T_arr, NULL, NULL);
clEnqueueWriteBuffer(queue, d_P_arr, CL_TRUE, 0, problem_size * sizeof(double), h_P_arr, NULL, NULL);
clEnqueueWriteBuffer(queue, d_conc, CL_TRUE, 0, problem_size * 31 * sizeof(double), h_conc, NULL, NULL);
clEnqueueWriteBuffer(queue, d_Fi, CL_TRUE, 0, problem_size * 5 * sizeof(double), h_Fi, NULL, NULL);

    size_t global_work_size[3] = {problem_size, 0, 0};
    size_t local_work_size[3] = {0, 0, 0};

    /* run kernel */
    check_err(clEnqueueNDRangeKernel(queue, kernel, 1, NULL, global_work_size, local_work_size, 0, NULL, NULL));

    // Wait for the command queue to get serviced before reading back results
    clFinish(queue);

    /* Memory Transfers out */
    clEnqueueReadBuffer(queue, d_wdot, CL_TRUE, 0, problem_size * 32 * sizeof(double), h_wdot, NULL, NULL);
}

/*
Create opencl kernel

Parameters
----------
num_devices : uint
    The number of devices to use.  If for GPUs/accelerators, this is the # of GPUs to use
    If for CPUs, this is the number of logical cores to use
kernel : cl_kernel [out]
    The kernel output will be stored here
program : cl_program [out]
    The built OpenCL program will be stored here
context : cl_context [out]
    The opencl context for execution
queue : cl_command_queue [out]
    The opencl execution queue
*/
void init(cl_uint num_devices, cl_kernel kernel, cl_program program, cl_context context,
            cl_command_queue queue)
{
    cl_platform_id platform_id[NUM_PLATFORMS];
    cl_device_id device_ids[MAX_DEVICE];
    cl_uint ret_num_platforms;
    cl_uint ret_num_devices;
    cl_uint num_cores;
    cl_int return_code;

    char* kernel_path = "/home/nick/spyJac/pyjac/tests/out/spec_rates.ocl";
    char* platform_check = "Intel(R) Corporation";
    char* build_options = "-I/opt/opencl-headers/ -I/home/nick/spyJac/pyjac/tests/out -O3 -cl-std=CL1.2";

    cl_device_type device_type = 2;

    FILE *fp;
    unsigned char *source_bin;

    /* Load kernel source code */
    fp = fopen(kernel_path, "rb");
    if (!fp) {
        exit(-1);
    }
    //find file size
    fseek(fp, 0L, SEEK_END);
    size_t source_size = ftell(fp);
    rewind(fp);

    //read file
    source_bin = (char*)malloc(source_size);
    assert(fread(source_bin, 1, source_size, fp) == source_size && "Error reading source binary...");
    fclose(fp);

    /* Get platform/device information */
    check_err(clGetPlatformIDs(NUM_PLATFORMS, platform_id, &ret_num_platforms));
    cl_platform_id pid = NULL;
    for (int i = 0; i < ret_num_platforms; ++i)
    {
        //check if intel
        char pvendor[100];
        size_t psize = 100 * sizeof(char);
        check_err(clGetPlatformInfo(platform_id[i], CL_PLATFORM_VENDOR, psize, pvendor, NULL));
        if(strstr(pvendor, platform_check) != NULL)
        {
            pid = platform_id[i];
            break;
        }
    }

    if (device_type == CL_DEVICE_TYPE_CPU)
    {
        //num devices is actually the number of cores
        //Hence, we're going to create a subdevice limited to that # of cores
        num_cores = num_devices;
        //all systems tested show multi-cpus as a single device.  May need to update for MPI etc.
        num_devices = 1;
    }
    else if (num_devices >= MAX_DEVICE)
    {
        printf("Cannot create program with %s devices, please update MAX_DEVICE definition.\n");
        exit(EXIT_FAILURE);
    }

    //get the device to compile for
    check_err(clGetDeviceIDs(pid, device_type, num_devices, device_ids, &ret_num_devices));

    //now we need to create subdevices for the CPU
    if (device_type == CL_DEVICE_TYPE_CPU)
    {
        cl_uint num_compute;
        //first get the maximum number of sub partitions (i.e. logical threads)
        check_err(clGetDeviceInfo(device_ids[0], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(num_compute), &num_compute, NULL));
        assert(num_cores <= num_compute && "Too many cores used...");

        //ok, now we know we're ok
        //let's create a subdevice with the required number of compute units
        // Partition properties
        cl_device_partition_property properties[3];
        // Partition type
        properties[0] = CL_DEVICE_PARTITION_BY_COUNTS;
        // number of compute units
        properties[1] = 3;
        // List end
        properties[2] = CL_DEVICE_PARTITION_BY_COUNTS_LIST_END;

        // Specifies the size of the out_devices array
        cl_uint num_sub_devices = 1;
        // Provides a buffer for the generated subdevices with a number of elements specified by num_sub_devices
        cl_device_id sub_device_ids;
        // Create the subdevices for the device_id device
        check_err(clCreateSubDevices(device_ids, properties, num_sub_devices, &sub_device_ids, &ret_num_devices));
        //and assign to the device_ids
        device_ids = sub_device_ids;
    }

    //create context
    context = clCreateContext(NULL, ret_num_devices, &device_ids, NULL, NULL, &return_code);
    check_err(return_code);

    //create queue
    queue = clCreateCommandQueue(context, device_ids, 0, &return_code);
    check_err(return_code);

    /* Create Kernel program from the read in source binary */
    cl_int bin_status;
    program = clCreateProgramWithBinary(context, ret_num_devices, &device_ids, &source_size, &source_bin, &bin_status, &return_code)
    check_err(bin_status);
    check_err(return_code);

    /* Build Program */
    return_code = clBuildProgram(program, 1, &device_id, build_options, NULL, NULL);
    if (return_code != CL_SUCCESS)
    {
          printf("OpenCL failed to build the program...\n");

          size_t len;
          char *buffer;
          check_err(clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, sizeof(char*), NULL, &len));
          buffer = calloc(len, sizeof(char));
          check_err(clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, len * sizeof(char), buffer, NULL));
          printf("%s\n", buffer);
          free(buffer);

          clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, sizeof(char*), NULL, &len);
          buffer = calloc(len, sizeof(char));
          clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_STATUS, len * sizeof(char), buffer, NULL);
          printf("%s\n", buffer);
          free(buffer);

          check_err(return_code);
    }

    /* Alloc buffers */
    Atroe = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 3 * sizeof(double), NULL, &return_code);
check_err(return_code);
B = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 31 * sizeof(double), NULL, &return_code);
check_err(return_code);
Btroe = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 3 * sizeof(double), NULL, &return_code);
check_err(return_code);
Fcent = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 3 * sizeof(double), NULL, &return_code);
check_err(return_code);
Fi = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 5 * sizeof(double), NULL, &return_code);
check_err(return_code);
Kc = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 12 * sizeof(double), NULL, &return_code);
check_err(return_code);
P_arr = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * sizeof(double), NULL, &return_code);
check_err(return_code);
Pr = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 5 * sizeof(double), NULL, &return_code);
check_err(return_code);
T_arr = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * sizeof(double), NULL, &return_code);
check_err(return_code);
X = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 1 * sizeof(double), NULL, &return_code);
check_err(return_code);
conc = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 31 * sizeof(double), NULL, &return_code);
check_err(return_code);
cp = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 31 * sizeof(double), NULL, &return_code);
check_err(return_code);
cv = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 31 * sizeof(double), NULL, &return_code);
check_err(return_code);
h = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 31 * sizeof(double), NULL, &return_code);
check_err(return_code);
kf = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 15 * sizeof(double), NULL, &return_code);
check_err(return_code);
kf_fall = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 5 * sizeof(double), NULL, &return_code);
check_err(return_code);
kr = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 12 * sizeof(double), NULL, &return_code);
check_err(return_code);
pres_mod = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 8 * sizeof(double), NULL, &return_code);
check_err(return_code);

rop_fwd = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 15 * sizeof(double), NULL, &return_code);
check_err(return_code);
rop_net = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 15 * sizeof(double), NULL, &return_code);
check_err(return_code);
rop_rev = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 12 * sizeof(double), NULL, &return_code);
check_err(return_code);
thd_conc = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 8 * sizeof(double), NULL, &return_code);
check_err(return_code);
u = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 31 * sizeof(double), NULL, &return_code);
check_err(return_code);
wdot = clCreateBuffer(context, CL_MEM_READ_WRITE, problem_size * 32 * sizeof(double), NULL, &return_code);
check_err(return_code);
T_arr = (double*)malloc(problem_size * sizeof(double));
P_arr = (double*)malloc(problem_size * sizeof(double));
conc = (double*)malloc(problem_size * 31 * sizeof(double));
Fi = (double*)malloc(problem_size * 5 * sizeof(double));
wdot = (double*)malloc(problem_size * 32 * sizeof(double));
for(int i_setter = 0; i_setter < problem_size * 5; ++i_setter)
    h_Fi[i] = 1;

memset(h_wdot, 0, problem_size * 32 * sizeof(double*));


    /* Create OpenCL Kernel */
    kernel = clCreateKernel(program, "spec_rates", &ret);
    check_err(ret);

    /* Kernel arg setting */
    check_err(clSetKernelArg(kernel,0, problem_size * 3 * sizeof(double), Atroe));
check_err(clSetKernelArg(kernel,1, problem_size * 31 * sizeof(double), B));
check_err(clSetKernelArg(kernel,2, problem_size * 3 * sizeof(double), Btroe));
check_err(clSetKernelArg(kernel,3, problem_size * 3 * sizeof(double), Fcent));
check_err(clSetKernelArg(kernel,4, problem_size * 5 * sizeof(double), Fi));
check_err(clSetKernelArg(kernel,5, problem_size * 12 * sizeof(double), Kc));
check_err(clSetKernelArg(kernel,6, problem_size * sizeof(double), P_arr));
check_err(clSetKernelArg(kernel,7, problem_size * 5 * sizeof(double), Pr));
check_err(clSetKernelArg(kernel,8, problem_size * sizeof(double), T_arr));
check_err(clSetKernelArg(kernel,9, problem_size * 1 * sizeof(double), X));
check_err(clSetKernelArg(kernel,10, problem_size * 31 * sizeof(double), conc));
check_err(clSetKernelArg(kernel,11, problem_size * 31 * sizeof(double), cp));
check_err(clSetKernelArg(kernel,12, problem_size * 31 * sizeof(double), cv));
check_err(clSetKernelArg(kernel,13, problem_size * 31 * sizeof(double), h));
check_err(clSetKernelArg(kernel,14, problem_size * 15 * sizeof(double), kf));
check_err(clSetKernelArg(kernel,15, problem_size * 5 * sizeof(double), kf_fall));
check_err(clSetKernelArg(kernel,16, problem_size * 12 * sizeof(double), kr));
check_err(clSetKernelArg(kernel,17, problem_size * 8 * sizeof(double), pres_mod));
check_err(clSetKernelArg(kernel,18, sizeof(int), &problem_size));
check_err(clSetKernelArg(kernel,19, problem_size * 15 * sizeof(double), rop_fwd));
check_err(clSetKernelArg(kernel,20, problem_size * 15 * sizeof(double), rop_net));
check_err(clSetKernelArg(kernel,21, problem_size * 12 * sizeof(double), rop_rev));
check_err(clSetKernelArg(kernel,22, problem_size * 8 * sizeof(double), thd_conc));
check_err(clSetKernelArg(kernel,23, problem_size * 31 * sizeof(double), u));
check_err(clSetKernelArg(kernel,24, problem_size * 32 * sizeof(double), wdot));

    free(source_bin);
}

/*
Cleanup the opencl kernel
*/
void finalize(cl_command_queue queue, cl_context context,
                cl_kernel kernel, cl_program program)
{
    /* Finalization */
    check_err(clFlush(queue));
    check_err(clFinish(queue));
    check_err(clReleaseKernel(kernel));
    check_err(clReleaseProgram(program));

    /* Memory Frees */
    check_err(clReleaseMemObject(Atroe))
check_err(clReleaseMemObject(B))
check_err(clReleaseMemObject(Btroe))
check_err(clReleaseMemObject(Fcent))
check_err(clReleaseMemObject(Fi))
check_err(clReleaseMemObject(Kc))
check_err(clReleaseMemObject(P_arr))
check_err(clReleaseMemObject(Pr))
check_err(clReleaseMemObject(T_arr))
check_err(clReleaseMemObject(X))
check_err(clReleaseMemObject(conc))
check_err(clReleaseMemObject(cp))
check_err(clReleaseMemObject(cv))
check_err(clReleaseMemObject(h))
check_err(clReleaseMemObject(kf))
check_err(clReleaseMemObject(kf_fall))
check_err(clReleaseMemObject(kr))
check_err(clReleaseMemObject(pres_mod))
check_err(clReleaseMemObject(problem_size))
check_err(clReleaseMemObject(rop_fwd))
check_err(clReleaseMemObject(rop_net))
check_err(clReleaseMemObject(rop_rev))
check_err(clReleaseMemObject(thd_conc))
check_err(clReleaseMemObject(u))
check_err(clReleaseMemObject(wdot))
check_err(free(Fi))
check_err(free(P_arr))
check_err(free(T_arr))
check_err(free(conc))
check_err(free(wdot))

    check_err(clReleaseCommandQueue(queue));
    check_err(clReleaseContext(context));
}

int main(int argc, char* argv[])
{

    //check args
    assert(argc >= 3 && "Missing arguements...");

    //arglist is:
    //#0 - the program name
    //#1 - the problem size
    //#2 - the number of cores [CPU only] or number of GPUs / accelerators [GPU only]

    //first compile to binary
    compiler();

    cl_uint problem_size = atoi(argv[1]);
    cl_uint num_devices = atoi(argv[2]);

    cl_kernel kernel = NULL;
    cl_program program = NULL;
    cl_context context = NULL;
    cl_command_queue = NULL;
    init(num_devices, kernel, program, context, queue);

    //read input data
    read_initial_conditions("${data_filename}", problem_size,
                                T_host, conc_host, var_host,
                                C);

    execute_kernel(problem_size, kernel, queue, double* h_T_arr, double* h_P_arr, double* h_conc, double* h_Fi, double* h_wdot);

    finalize(queue, context, kernel, program);
}